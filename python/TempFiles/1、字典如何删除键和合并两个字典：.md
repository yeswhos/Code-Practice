1、字典如何删除键和合并两个字典：
删除：del dic[key]
合并：dic.update(dic_2)

2、python的GIL（Global Interpreter Lock）：
GIL是全局解释器锁，假如同一进程中有多个线程执行，一个线程在运行python时，就会霸占整个进程，就像是加了一把锁也就是GIL。
使该进程中其他线程无法进行，等该python线程运行完了，其他线程才能运行。
如果线程遇到了耗时的操作，GIL就会自己解开，让其他线程也能进行。
所以多线程其中线程也不能并行，都是有前后执行顺序的。
而多进程中每个进程系统资源都是单独分配的，相当于每个进程都有一个python解释器，所以进程可以实现多个进程同时执行，缺点是进程系统资源消耗过大。

3、*arg, *kwargs含义：
可以将不定量参数传给函数。
arg是发一个非键值对的不定量参数，来给函数
kwargs是允许将不定长度的键值对参数，来给参数

4、简述面向对象中__new__和__init__区别（看不懂，不想看）
__init__：初始化方法，创建对象后，就立刻被默认调用了，可接收参数
__new__：至少有个参数cls，代表当类。
1、__new__至少要有一个参数cls，代表当前类，此参数在实例化时由Python解释器自动识别
2、__new__必须要有返回值，返回实例化出来的实例，这点在自己实现__new__时要特别注意，可以return父类（通过super(当前类名, cls)）__new__出来的实例，或者直接是object的__new__出来的实例
3、__init__有一个参数self，就是这个__new__返回的实例，__init__在__new__的基础上可以完成一些其它初始化的动作，__init__不需要返回值
4、如果__new__创建的是当前类的实例，会自动调用__init__函数，通过return语句里面调用的__new__函数的第一个参数是cls来保证是当前类实例，如果是其他类的类名，；那么实际创建返回的就是其他类的实例，其实就不会调用当前类的__init__函数，也不会调用其他类的__init__函数。

5、简述with方法打开处理文件帮我我们做了什么？
就打开文件或者写文件的时候可能会遇到异常，所以最好捕获异常，然后无论发生什么都要close掉，但with就带了最后close动作

6、map函数的使用：列表[1,2,3,4,5],请使用map()函数输出[1,4,9,16,25]，并使用列表推导式提取出大于10的数，最终输出[16,25]。

7、python中生成随机整数、随机小数、0--1之间小数方法
random.randint(5, 10)
random.random()

8、10个Linux常用命令
ls pwd cd touch rm mkdir tree cp mv cat more grep echo

9、可变及不可变数据类型：
不可变：int，string，tuple，如果改变了变量的值相当于就换了一个对象
可变：list，dict，改变值而且不会新建对象

10、lambda：
    1、用lambda函数实现两个数相乘
    res = lambda(a, b: a * b)
    print(res(2, 3))
    2、使用lambda函数对list排序foo = [-5,8,0,4,9,-4,-20,-2,8,2,-4]，输出结果为[0,2,4,8,8,9,-2,-4,-4,-5,-20]，正数从小到大，负数从大到小
    list = sorted(list_1, key=x:(x<0, abs(x)))
    3、对list排序foo = [-5,8,0,4,9,-4,-20,-2,8,2,-4],使用lambda函数从小到大排序
    list = sorted(list_1, key=x:x)
    4、列表嵌套字典的排序，分别根据年龄和姓名排序
    foo = [{"name":"zs","age":19},{"name":"ll","age":54},
    {"name":"wa","age":17},{"name":"df","age":23}]
    list = sorted(list_1, key=lambda x:x[name])
    5、根据字符串长度排序
    list = sorted(list_1, key=lambda x:len(x))

11、字典值排序：字典根据键从小到大排序
new_dic = sorted(dic.items(), key=lambda i:i[0], reversed=False)

12、列表：列表推导式求列表所有奇数并构造新列表
list = (for i in list_1 if i % 2 == 1)

13、赋值，深拷贝，浅拷贝
浅拷贝：第一种情况：复制的 对象中无 复杂 子对象，原来值的改变并不会影响浅复制的值，同时浅复制的值改变也并不会影响原来的值。原来值的id值与浅复制原来的值不同。
第二种情况：复制的对象中有 复杂 子对象 （例如列表中的一个子元素是一个列表）， 改变原来的值 中的复杂子对象的值 ，会影响浅复制的值。

深拷贝：完全复制独立，包括内层列表和字典

赋值：对象中有无子对象，都会相应的改变

14、列表推导式、字典推导式、生成器
列表推导式：list = [i for i in range(10)]
生成器：list = (i for i in range(10))
字典推导式：dic = {k:random.randint(4, 9) for i in ['a', 'b', 'c', 'd', 'e']}

15、python垃圾回收机制
python垃圾回收主要以引用计数为主，标记-清除和分代清除为辅的机制。
引用计数算法：
    当有1个变量保存了对象的引用时，此对象的引用计数就会加1
    当使用del删除变量指向的对象时，如果对象的引用计数不为1，比如3，那么此时只会让这个引用计数减1，即变为2，当再次调用del时，变为1，如果再调用1次del，此时会真的把对象进行删除

16、生成器：

    1、定义：
        通过列表生成式，我们可以直接创建一个列表，但是，受到内存限制，列表容量肯定是有限的，而且创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。

    2、好处：
        所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间，在Python中，这种一边循环一边计算的机制，称为生成器：generator

    3、创建一个生成器：
        要创建一个generator，有很多种方法，第一种方法很简单，只有把一个列表生成式的[]中括号改为（）小括号，就创建一个generator，比如[for i in range(10)] 改成 (for i in range(10))

    4、获取一个元素：
        如果要一个个打印出来，可以通过next（）函数获得generator的下一个返回值。或者直接用for循环来迭代，毕竟她是一边循环一遍计算的机制

17、装饰器：
    1、先是有闭包的特质：在outer函数内，又定义了一个inner函数，并且inner函数又引用了外部函数outer的变量x，这就是一个闭包了。
    2、装饰器就是：python装饰器就是用于拓展原来函数功能的一种函数，这个函数的特殊之处在于它的返回值也是一个函数，使用python装饰器的好处就是在不用更改原函数的代码前提下给函数增加新的功能。使用时，再需要的函数前加上@demo即可。

18、全局变量与局部变量相同问题
    1、定义在函数外部的是全局变量，内部是局部变量
    2、函数中修改**不可变的全局变量**需要用global声明，否则出错。本质是函数内部不声明的话，无法改变全局变量的指向，即不能将全局变量指向新的数据。修改**可变的全局变量**则不需要声明。
    3、如果全局和局部名字相同，使用的则是局部变量

19、python变量引用及销毁
定义一个变量的时候，如a=1，其实是程序开辟了一块内存空间，然后把Kwan放进去，再让变量名指向1所在的内存地址。a=2的时候就是变量名指向了另一个内存地址。

20、dict的底层结构，list和tuple的区别
dict 底层使用的哈希表，查找的时候时间复杂度O（1）
list可变，tuple不可变。
tuple是保存的引用不可变，也就是没法改变这个对象，但假如这个对象是可变的，假如里面还有个list，那这个list还是可变的