From Solar https://www.solare.pub/2020/11/14/265/

**网络**

1. 网络分层， 7层网络模型，TCP/IP模型
   1. 物理层，链路层，网络层，传输层，应用层（TCP/IP划分）
   2. 物理层，链路层，网络层，传输层，会话层，表示层，应用层（OSI七层网络模型）
   3. 物理层：网络的物理连接，如网线，无线信道等
   4. 数据链路层：建立连接，对数据检错，纠错。例如网卡。链路层发送Frames。如Mac帧。
   5. 网络层：建立网络连接，分时复用数据链路，错误检测和恢复，流量控制。例如网关和路由器。网络层是点对点，即从一个设备到另一个设备。网络层发送Package，如IP数据包。
      1. IP数据包是硬件无关的，在具体发送到某个设备时，需要使用ARP来获取硬件地址。
      2. 每个主机都有一个ARP高速缓存，通过查阅此缓存找到目标硬件地址。如果不在同一个局域网，则把数据包发送给路由器，让路由器在上层网络里寻找。
   6. 传输层：第一个端到端的层次。即从一个端口（应用程序）到另一个应用程序。
2. TCP/UDP区别
   1. 工作在传输层
   2. TCP是面向连接的协议，需要通过三次握手建立连接，四次挥手关闭连接
   3. TCP连接保证发送数据正确性和数据顺序
   4. TCP的包结构更复杂，处理起来更消耗资源
   5. TCP是一对一的，UDP可以一对一，也可以一对多
   6. TCP有拥塞控制，但UDP没有
   7. UDP是无连接的，包结构简单，不保证数据顺序，尽最大努力发送数据。常用于视频播放等，还有Ping
3. TCP的滑动窗口、拥塞控制过程、三次握手、四次挥手以及每个过程的状态，为什么三次四次
   1. TCP的三次握手：
      1. 连接发起方发送连接请求，带有一个同步序列号Seq=X，声明想要连接的端口
      2. 接收方如果同意连接，则回复一个ACK，X+1，并带有一个Seq=Y
      3. 发起方收到后，确认收到同意，回复ACK，Y+1 Seq=Z
      4. 三次握手是避免死锁，如果仅有两次握手，当接收方收到请求后就进入连接状态，此时如果它的回复丢失，请求方没有收到的话，请求方会认为没有建立连接。请求方等待接收方的回复，接收方等待请求方的数据。
   2. TCP四次挥手
      1. 主动方发送断开请求，Seq=X
      2. 被动方回复ACK=X+1，Seq=Z，主动方到被动方方向断开
      3. 被动方发送完毕数据后，发送Fin=1，ACK=X，Seq=Y
      4. 主动方回复ACK=Y+1，Seq=X
      5. 四次挥手是因为TCP是全双工的，发送接收两个方向都需要断开。某一方发送完成后，可以触发断开，但另一方可能还没发送结束。需要等发送完成后再断开。
   3. TCP滑动窗口和拥塞控制
      1. 滑动窗口是用于流量控制的协议，避免拥塞的产生。窗口是接收方能够接受的数据量，发送方在发送窗口大小的数据后，等待对方的ack报文，并向前滑动窗口。窗口的大小是在接收方回复的报文里规定的。
      2. 拥塞处理机制
         1. 慢启动
            1. 发送方设定一个阈值
            2. 发送方开始发送数据时，首先发送1字节的试探报文
            3. 每当收到确认后，报文大小翻倍
            4. 达到阈值后，使用拥塞避免算法。
         2. 拥塞避免算法
            1. 每经过一个RTT后，拥塞窗口+1
            2. 出现网络拥塞，如丢包后，将慢开始门限设为原来的一半，重新从1慢开始。
         3. 快恢复，快重传
            1. 接收方如果发现一个包丢失了，则每收到后续的包，继续发送对丢失包的重传请求。
            2. 发送发收到三个一样的确认，则知道该包丢失，立刻重传该包。
            3. 发送方开始执行快恢复
               1. 慢开始门限减半
               2. cwnd（即窗口）设为门限
               3. 直接开始拥塞避免算法（每次+1）
         4. 快恢复能够执行是因为收到了三个连续确认，这证明了网络状况尚可。如果没有收到连续确认，而是超时，则证明网络状况可能不好，需要拥塞避免。
4. DNS解析
   1. DNS是Domain Name System，即把域名和IP地址对应起来。
   2. 直接使用IP有较多不便。一是输入困难，而是IP地址可能改变。
   3. 域名是字符组合，可以设置有意义的字符，如solare.pub
   4. 使用域名进行访问，在建立连接时首先把域名通过DNS服务器解析成真正的IP。
   5. 解析域名时，首先在本地查找，如host文件，如果本地不存在，则向本地域名服务器查找，如果本地域名服务器也没有记录，则逐层向上查找，直到根域名服务器。这是递归查找。每一级查找是上一级进行的，而不是主机进行的。
   6. 如果根域名服务器也不知道IP地址，则告诉来查找的顶级域名服务器，应该向哪个服务器查找。该服务器也可能直接给出地址，或提供下一个查找位置。
5. HTTP/HTTPs
   1. HTTP协议基础
      1. HTTP协议是建立在TCP协议基础上的。Hyper Text Transfer Protocol。
      2. 客户端向服务端请求时，只传送方法和路径，协议简单。
      3. 无连接，每次连接只处理一个请求。
      4. 无状态，HTTP协议不记录之前发送的状态/数据等。
      5. URI，统一资源标识符，URL是一种特殊的URI，包含了查找资源的足够的信息。 HTTP://是协议；www.baidu.com是域名；:8080是端口；/news/index.asp是资源路径； ？后是参数；#后是锚，对页面位置的一个定义。
      6. 工作原理
         1. 客户端连接到Web服务器，建立TCP连接
         2. 客户端发送HTTP请求
         3. 服务端返回HTTP响应
         4. 释放TCP连接（如果connection模式为close）或保持连接（keepalive)
   2. Request请求
      1. 请求行，包括类型，请求的资源和HTTP版本
      2. 请求头，包括Host，User-Agent，各种协议等
      3. 空行
      4. 请求数据
   3. 请求方法
      1. GET，请求数据附在URL之后，地址栏明文存储，不安全，也不适合传输大量数据
      2. POST，数据内容在HTTP包的包体内，可以自行加密
      3. PUT
      4. DELETE
   4. Response
      1. 状态行，版本，状态码，状态消息
      2. 消息报头，附加信息，如时间，内容类型等
      3. 空行
      4. 响应正文 如HTML文件
   5. 状态码
      1. 1XX，请求已接受，继续处理
      2. 2XX，成功， 如200 OK
      3. 3xx，重定向，要完成请求需要进一步操作
      4. 4xx，客户端错误，403 Forbidden， 404 Not Found
      5. 5xx，服务端错误，500 Internal Server Error
   6. HTTPS
      1. HTTP协议里的数据明文传输，虽然可以自己加密，但只有双方约定好才可以正常运行。对于浏览器访问页面的需求，无法实现安全。
      2. 在HTTP的基础上，通过SSL/TLS安全协议，将传输内容加密，保证安全。
      3. HTTPS采用非对称加密+对称加密。从CA获取证书用于验证服务端的身份和获取公钥，方法是对身份进行数字签名，用私钥加密。客户端内置CA的私钥，可以解密证书，并且验证公钥是否和身份对应。身份验证通过后，客户端获取服务端的公钥，生成一个随机key用于后续的对称加密，将随机key用公钥加密，发送给服务端，服务端使用自身的私钥解密获取key。后续对话使用key加密数据。
   7. 加密算法
      1. 签名加密MD5，对信息进行摘要，保证信息没有被篡改，还有SHA1
      2. 对称加密AES，分块，对称加密
      3. 非对称加密RSA，公钥加密数据，私钥解密数据。私钥加密签名，公钥验证签名。
6. 浏览器输入url并回车的过程
   1. 解析URL域名对应的IP地址
   2. 建立TCP连接
   3. 浏览器发出读取文件的请求，该请求作为TCP三次握手第三个报文的数据发送给服务端。
   4. 服务器进行响应，把html文本发送给浏览器。
   5. 释放TCP连接
   6. 浏览器将HTML文本显示
7. Session和Cookie的区别以及如何解决分布式session问题
   1. Cookie保存在客户端，客户端请求时带上Cookie去服务端请求。如果客户端篡改或删除Cookie则请求异常。
   2. Session保存在服务端，客户端只使用Cookie保存Session的ID，客户端请求时带上SessionID， 服务端通过ID查找对应的Session。如果删除Cookie或更换浏览器，服务端为此用户（如果是登录用户）再次创建此ID，依然能够读取到这个Session。

**操作系统**

1. 内存管理方式
   https://blog.csdn.net/qq_29677867/article/details/91038642
   
   1. 内存
      1. 内存用于存放数据或指令
      2. 程序运行时无法直接使用内存的物理地址，使用的是逻辑地址（即相对地址）
      3. 程序编辑，编译完成后，要进行链接并装入内存。
      4. 程序装入：绝对装入，静态重定位和动态重定位三种方案。重定位即根据实际装入内存起始位置，调整代码中所有地址位置。静态重定位要求分配所有的内存空间，动态重定位允许程序在内存中移动，在运行过程中申请内存。
      5. 程序链接：静态链接：所有目标模块连接成一个完整整体，一起装入；装入时动态链接，个目标模块装入内存时，边装入边链接；运行时动态链接：运行中需要目标模块时才链接。
   2. 内存管理
      1. 内存空间的分配与回收由操作系统完成。
      2. 内存空间通过虚拟存储技术或自动覆盖技术，从逻辑上扩充内存
      3. 地址转换，程序中逻辑地址与内存中物理地址不一致，需要转换
      4. 内存保护，保证各程序在各自独立的存储空间运行，互不干扰
   3. 内存覆盖和交换
      1. 把用户空间分为固定区和若干覆盖区。活跃部分放在固定去，其他部分按调用关系放入覆盖区，其他端放在外存，需要时调入覆盖区。
      2. 内存覆盖技术使得不用把进程所有信息放入内存。
      3. 内存交换：内存空间紧张时，把部分进程暂时换出外存，把外存中已经具备运行条件的进程放在内存。
   4. 连续分配管理方式（整个程序的内存连续分配）
      1. 单一连续分配
      2. 固定分区分配，预先划分好内存空间，每个空间只放入一道作业。
      3. 动态分区分配， 不预先划分内存空间，进程装入内存时，根据进程大小动态建立分区，并使分区大小正好适合进程需要。
   5. 动态分区分配算法：
      1. 首次适应算法，找到第一个能满足的
      2. 最佳适应方法，优先使用满足条件的小分区
      3. 最坏适应算法，每次优先使用最大的分区
      4. 临近适应算法，每次从上次查找结束位置开始检索
   6. 分页存储
      1. 连续存储会产生碎片，如果将一个进程分散到许多不连续的空间，就可以避免内存紧缩，减小碎片。
      2. 将物理空间分区，引入索引，将逻辑地址映射到物理地址，按照分区大小是否固定分为分页存储和分段存储
      3. 分页存储
         1. 将内存空间分为一个个大小相等的分区（页帧），每个页有一个编号（帧号）。用户进程的地址空间也分为同等大小的区域，称为页，编号称为页号。操作系统以页为单位为各个进程分配内存空间，进程的每个页放到一个帧里，一一对应。
         2. 根据是否把所有页面装入内存分为：基本分页存储管理和请求分页存储管理。
         3. 逻辑地址转换，后K位为页内偏移量，前面为页号
         4. 页表，用于记录每个页面在内存中存放的物理位置。页号对应帧号。
         5. 快表，页表寄存器
         6. 两级页表，单级页表占用空间太多，对页表进行分组，不连续存储，再对分组的页表建立一张页表，即两级页表
      4. 分段存储
         1. 进程的地址空间按照自身逻辑关系划分为若干个段，每个段有个段名
         2. 以段为单位进行分配，每个段占据连续空间，各段之间可以不相邻
         3. 段表记录段号，段长和基址
      5. 分段，分页管理
         1. 分页是系统行为，用户不可见。分段是为了更好满足用户需求，分段对用户可见
         2. 页大小固定，段不固定
         3. 分段中，总是把程序全部装入内存
      6. 段页式管理
         1. 先分段，段内分页，避免内存碎片
   7. 虚拟内存
      1. 所有数据都在内存中，即使是不常用的，导致并发度下降。
      2. 局部性原理，时间局部性：最近执行的指令很可能再次执行，最近访问的数据不久可能被再次访问；空间局部性：一旦程序访问了某个存储单元，不久后它附近的单元也可能被访问
      3. 基于局部性原理，把常用的部分放入内存，暂时不用的放到外存
         1. 当发现所需信息不在内存，则从外存调入内存
         2. 若空间不够，则把暂时用不到的信息放到外存
      4. 请求分页管理
         1. 操作系统需要知道某个页面是否已经在内存
         2. 缺页中断
         3. 页面置换算法
            1. 最佳置换：每次选择淘汰的页面以后用不使用
            2. 先进先出：淘汰先进入内存的页面
            3. LRU，最近使用最少，使用一个链表实现，每次命中（或创建)的数据放到链表头部，淘汰时从尾部淘汰。
2. 进程和线程
   
   1. 进程和线程的区别
      1. 每个应用程序至少包括一个进程，进程是操作系统资源分配的基本单位。每个进程可能包括多个线程。
      2. 每个进程有独立的代码和数据空间，进程间切换开销较大。进程间地址空间和资源相互独立。
      3. 每个线程有自己的运行栈和程序计数器。线程间共享本进程的地址空间和资源（IO，CPU等），线程间切换效率较高，负担较小。私有程序计数器是为了实现线程切换。
      4. 单个进程崩溃不会引起其他进程或系统崩溃，单个线程崩溃会引起进程崩溃。
   2. 进程
      1. 进程状态
         1. 等待，等待某个事件完成
         2. 就绪，等待系统分配处理器以便运行
         3. 运行，正在运行
      2. 进程调度
         1. FCFS，先来先服务，执行过程中不会被中断
         2. 短作业优先，对预计执行时间段的作业先分配
         3. 响应比（综合FCFS和短作业，计算响应比）
         4. 时间片轮转，每个进程被分配一个时间段，超出后轮转
         5. 多级反馈，进程分为不同的优先级队列，优先响应高优先级，同一优先级轮转。按照时间顺序进入的进程，进入第一个空闲的队列。时间片执行结束后从最高优先级查找。
      3. 进程间通信
         1. Pipe（linux）
         2. 消息队列，一个消息的链表，保存在内核中
         3. 共享内存，多个进程共享一个给定的内存区
         4. 套接字，双方扮演服务器端和客户端，通过地址建立连接和发送消息
   3. 线程
      1. 线程生命周期
         1. 新建
         2. 就绪
         3. 运行
         4. 阻塞
         5. 死亡
      2. 线程优先级
         1. 优先级高的线程可能先被调用
      3. Java线程创建
         1. 继承Thread类，Thread类也实现了Runnable接口
         2. 实现Runnable接口，通过Thread构造函数实例化新Thread
         3. 通过Callable和Future创建线程
      4. 线程间通信
         1. synchronized, notify, wait
         2. Lock和condition
         3. volatile关键字修饰的变量值对所有线程可见，而不是每个线程保存一份
         4. Atomic类型
         5. 管道通信
   4. 进程/线程同步问题
      1. 生产者消费者模型
         1. 问题描述
            1. 一个Buffer能够暂存商品
            2. 生产者生产商品，放到暂存区，如果buffer已满则停止生产
            3. 消费者从暂存区获取商品，如果buffer为空则等待生产
         2. 解决方法（Java）
            1. Buffer中的方法用synchronized修饰，如果达到停止条件则wait，否则执行并notifyAll
            2. 声明Lock，每个方法执行前上锁，等待条件，达成时通知另一方的条件。
            3. BlockingQueue（不太熟）
      2. 死锁的条件和解决方法
         1. 两个线程，互相持有对方需求资源的锁
         2. 互斥资源，资源只能被一个线程获得；请求和保持条件，进程因为请求资源而阻塞时，不释放已有资源；进程已获得资源在未使用完前，不能被剥夺，只能自己释放
         3. 预防死锁
            1. 获取所有资源并上锁，如果有资源无法获取则不获取
            2. 按照固定的顺序获取资源
            3. 超时放弃
         4. 解决死锁
            1. 记录每个进程和资源
            2. 建立资源分配表和进程等待表
            3. 发现死锁后剥夺资源或撤销进程
3. 文件管理系统
   https://www.cnblogs.com/leesf456/p/5626339.html
